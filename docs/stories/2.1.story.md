# Story 2.1 — Catalog models + SQLite adapter (list/get runs)
Story ID: S2.1
Epic ID: E2



Status: Ready for Review

User Story
- As a developer,
- I want Pydantic models and a SQLite Catalog adapter that power GET /backtests and GET /backtests/{id},
- So that the API can return correct shapes from a persistent catalog and enable the UI Runs List to function.

Context
- Implements read path only (list/get). Create/update paths will be handled in later stories.


Dependencies
- Depends on: S1.1 (backend skeleton), S1.3 (routes stubs)
- Blocks: S2.2 (list runs API), S2.3 (get run API)

References
- API Contracts: docs/api/openapi.yaml
- Catalog: docs/api/catalog.md
- Source Tree: docs/architecture/source-tree.md
- Data Models: docs/architecture.md
- Error Codes: docs/api/error-codes.md

Definition of Ready
- Context clarified; dependencies and references listed
- ACs measurable and testable; cite canonical docs
- QA mapping present (see docs/qa/story-to-qa-mapping.md)

Acceptance Criteria
1) `make db-apply` initializes data/catalog.sqlite; adapter connects with foreign_keys=ON
2) GET /backtests returns 200 with `{ items: [], total: 0, limit, offset }` on fresh DB
3) GET /backtests/{id} returns 404 with `{ error: { code: "RUN_NOT_FOUND", message } }` when not found
4) Pydantic models defined: Dataset, DatasetManifest, Run, RunManifest, RunMetrics (v2), aligned with Architecture Data Models
5) CatalogPort implemented by adapters/sqlite_catalog.py with methods: get_dataset, upsert_dataset (stub OK), get_run, list_runs, create_run (stub), set_run_status (stub)
6) services/backtests.py uses CatalogPort to fulfill list/get; api/routes/backtests.py wired accordingly
7) Structure follows Source Tree; new code passes lint

Dev Notes (sourced from architecture docs)
- Data Models: Dataset, DatasetManifest, Run, RunManifest, RunMetrics fields and relationships [Source: architecture.md#data-models]
- Catalog Schema (DDL): tables datasets, runs, run_metrics; indexes; runs_list view [Source: architecture.md#catalog-schema-sqlite-ddl]
- API Contracts: GET /backtests (filters: symbol/from/to/strategy_id, limit/offset/order), GET /backtests/{id} (404 error shape) [Source: architecture.md#api-contracts-rest--websocket]
- Source Tree and Ports: CatalogPort interface and placement; services/backtests orchestrates list/get [Source: architecture.md#source-tree-and-module-boundaries]
- NFRs/Operability: non-blocking handlers; structured errors; JSON logging fields (added later) [Source: architecture.md#non-functional-requirements-and-performance-budgets]

Technical Specifications
- SQLite: use row_factory to map columns; ensure TEXT timestamps are ISO-8601 UTC; enable foreign keys
- Models: Pydantic v2 BaseModel; config for from_attributes where useful; validate JSON TEXT fields for *_json columns (datasets.*)
- list_runs filtering:
  - symbol (via JOIN to datasets or runs_list view)
  - from/to date filtering against datasets.from_date/to_date where applicable
  - strategy_id direct on runs
  - order default "-created_at"; apply LIMIT/OFFSET
- Response mapping:
  - RunSummary: run_id, created_at, strategy_id, status, symbol, from, to, duration_ms (use view or join)
  - Run (detail): include artifacts paths and optional manifest link

Tasks / Subtasks
- Define Pydantic models in backend/domain/models.py (Dataset, DatasetManifest, Run, RunManifest, RunMetrics) [Source: architecture.md#data-models]
- Define CatalogPort in backend/ports/catalog.py (if not present); confirm interface matches story AC [Source: architecture.md#source-tree-and-module-boundaries]
- Implement adapters/sqlite_catalog.py:
  - Connect to data/catalog.sqlite (path configurable later)
  - Implement get_run(run_id) and list_runs(filters, limit, offset)
  - Implement get_dataset(dataset_id)
  - Stubs: upsert_dataset, create_run, set_run_status (raise NotImplementedError for now)
- Wire services/backtests.py to use CatalogPort for list/get
- Update api/routes/backtests.py to call services and return results per API Contracts; return REST error shape on 404
- Add minimal unit tests later (optional) and run `make lint`

Testing & Validation
- Start backend skeleton; apply DB: `make db-apply`
- GET /backtests → verify empty list shape
- GET /backtests/{id} with random id → verify 404 error shape

Project Structure Notes
- Keep adapter specific logic out of service layer; services depend on CatalogPort only
- Paths and file names must match the documented Source Tree

Definition of Done
- Endpoints return correct shapes powered by SQLite adapter; models align with Data Models; code organized per Source Tree; lints pass.


Dev Agent Record
- Agent Model Used: dev (James)

Tasks / Subtasks Checkboxes
- [x] Define Pydantic models in backend/domain/models.py
- [x] Define CatalogPort in backend/ports/catalog.py
- [x] Implement adapters/sqlite_catalog.py (get_run, list_runs, get_dataset; stubs for others)
- [x] Wire services/backtests.py to use CatalogPort
- [x] Update api/routes/backtests.py to call services for list/get and return REST error shape on 404
- [x] Apply DB schema via make db-apply (foreign_keys=ON)
- [x] Validate empty list and 404 behaviors

File List
- Added: backend/domain/models.py
- Added: backend/ports/catalog.py
- Added: backend/adapters/sqlite_catalog.py
- Added: backend/services/backtests.py
- Modified: backend/api/routes/backtests.py (use services for list/get)

Completion Notes
- DB bootstrapped from scripts/catalog_init.sql; foreign_keys=ON
- GET /backtests returns empty list with defaults; GET /backtests/{id} returns 404 shape
- Endpoints backed by adapter; no business write paths yet

Debug Log References
- rm data/catalog.sqlite (tool) → recreated cleanly
- make db-apply → 0
- make test → 7 passed


QA Results
- Gate: PASS
- Summary: SQLite adapter models support list/get; schema interactions validated by tests.
- Evidence: tests/backend/test_get_run_detail.py and catalog tests; make test green.
- Notes: Consider transaction boundaries for concurrent writers in future.

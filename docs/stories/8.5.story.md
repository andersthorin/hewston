# Story 8.5: WebSocket Proxy and Connection Management

**Epic**: Epic 8 â€” Backend-for-Frontend (BFF) Implementation
**Priority**: High
**Effort**: 4-5 days
**Dependencies**: Story 8.2 (Basic HTTP Proxy Implementation)
**Status**: Ready for Development

## User Story

As a **trader**,  
I want **reliable real-time streaming during backtest playback**,  
So that **I can watch strategy execution without connection interruptions or manual reconnection**.

## Story Context

### Existing System Integration

- **Integrates with**: Existing backend WebSocket endpoint (`/backtests/{id}/ws`)
- **Technology**: FastAPI WebSocket, asyncio connection management, message transformation
- **Follows pattern**: Existing WebSocket protocol and message formats
- **Touch points**: Frontend WebSocket client, backend streaming service, real-time data flow

### Business Context

This story enhances the critical real-time streaming functionality that enables traders to watch strategy execution in live-like playback. By improving connection reliability and management, we eliminate user frustration from connection drops and provide a smoother trading analysis experience.

## Acceptance Criteria

### Functional Requirements

1. **WebSocket Proxy Endpoint**
   - New endpoint `/api/v1/runs/{id}/stream` proxies backend WebSocket connections
   - Maintains existing WebSocket protocol and message formats
   - Supports all existing control commands (play, pause, seek, speed)
   - Preserves frame streaming performance (~30 FPS target)

2. **Connection Management**
   - Connection pooling for efficient backend WebSocket management
   - Automatic reconnection with exponential backoff when backend disconnects
   - Client connection lifecycle management (connect, disconnect, cleanup)
   - Health monitoring for both client and backend connections

3. **Message Transformation**
   - Transparent message forwarding between frontend and backend
   - Message filtering and transformation for client-specific optimizations
   - Frame rate adaptation based on client connection quality
   - Dropped frame counter and performance metadata

4. **Enhanced Reliability**
   - Automatic reconnection to backend without client intervention
   - Message queuing during temporary backend disconnections
   - Graceful handling of backend service restarts
   - Connection status reporting to frontend clients

### Integration Requirements

5. **Backend Compatibility**
   - Existing backend WebSocket endpoint continues to work unchanged
   - No modifications to backend streaming protocol or message formats
   - Backend authentication and authorization preserved
   - Existing performance characteristics maintained

6. **Frontend Integration**
   - WebSocket proxy maintains existing frontend client compatibility
   - Existing WebSocket connection logic can be simplified in frontend
   - Error handling and reconnection logic moved from frontend to BFF
   - Performance monitoring and status reporting enhanced

7. **Performance Requirements**
   - Maintain ~30 FPS streaming performance for real-time playback
   - WebSocket proxy latency under 50ms for message forwarding
   - Support for 50+ concurrent streaming connections
   - Efficient memory usage for connection pooling

### Quality Requirements

8. **Connection Reliability**
   - Automatic reconnection with exponential backoff (1s, 2s, 4s, 8s, max 30s)
   - Connection health monitoring with heartbeat messages
   - Graceful handling of network interruptions and backend restarts
   - Client notification of connection status changes

9. **Performance Monitoring**
   - Message latency tracking for proxy performance
   - Connection count and health metrics
   - Frame rate monitoring and dropped frame statistics
   - Backend connection pool utilization metrics

10. **Error Handling**
    - Comprehensive error scenarios (backend down, network issues, client disconnects)
    - Error message transformation and client notification
    - Fallback strategies for degraded performance
    - Logging and alerting for connection issues

## Technical Notes

### WebSocket Proxy Architecture
```python
class WebSocketProxy:
    def __init__(self):
        self.client_connections: Dict[str, Set[WebSocket]] = {}
        self.backend_connections: Dict[str, WebSocket] = {}
        self.connection_pool = ConnectionPool()
    
    async def handle_client_connection(self, run_id: str, client_ws: WebSocket):
        await client_ws.accept()
        
        # Ensure backend connection exists
        if run_id not in self.backend_connections:
            await self._establish_backend_connection(run_id)
        
        # Add client to connection group
        if run_id not in self.client_connections:
            self.client_connections[run_id] = set()
        self.client_connections[run_id].add(client_ws)
        
        # Start message forwarding
        await self._handle_client_messages(run_id, client_ws)
```

### Reconnection Strategy
- Exponential backoff: 1s, 2s, 4s, 8s, 16s, 30s (max)
- Reset backoff on successful connection
- Maximum reconnection attempts: unlimited (with circuit breaker)
- Health check interval: 30 seconds

### Message Filtering
- Client-specific frame rate adaptation
- Bandwidth-based message throttling
- Priority message handling (control vs data)
- Message queuing during reconnection

### Performance Optimization
- Connection pooling for backend WebSocket connections
- Async message forwarding with minimal latency
- Memory-efficient message buffering
- Connection cleanup and resource management

## Definition of Done

- [ ] **WebSocket Proxy**: `/api/v1/runs/{id}/stream` successfully proxies backend WebSocket connections
- [ ] **Connection Management**: Automatic reconnection and connection pooling implemented
- [ ] **Message Forwarding**: Transparent message forwarding maintains existing protocol
- [ ] **Performance**: ~30 FPS streaming performance maintained with <50ms proxy latency
- [ ] **Reliability**: Automatic reconnection handles backend disconnections gracefully
- [ ] **Monitoring**: Connection health and performance metrics collection implemented
- [ ] **Testing**: Comprehensive tests cover connection scenarios and failure modes
- [ ] **Documentation**: WebSocket proxy documentation and troubleshooting guide created

## Risk Assessment

### Primary Risk
**Performance Degradation**: WebSocket proxy introduces latency affecting real-time streaming

### Mitigation
- Async message forwarding with minimal processing
- Performance monitoring and alerting
- Load testing with concurrent connections

### Secondary Risk
**Connection Complexity**: Managing multiple client and backend connections increases complexity

### Mitigation
- Comprehensive connection lifecycle management
- Extensive testing of connection scenarios
- Clear error handling and logging

### Rollback Plan
- Feature flag to disable WebSocket proxy
- Frontend can connect directly to backend WebSocket
- Connection pool can be bypassed for troubleshooting

## Testing Strategy

### Unit Tests
- Connection management logic
- Message forwarding and transformation
- Reconnection algorithm and backoff logic
- Error handling for various failure scenarios

### Integration Tests
- End-to-end WebSocket proxy with mock backend
- Multiple client connection handling
- Backend disconnection and reconnection scenarios
- Message filtering and transformation

### Performance Tests
- Streaming performance with ~30 FPS target
- Concurrent connection handling (50+ clients)
- Message latency measurement
- Memory usage under load

### Load Tests
- High-frequency message streaming
- Connection churn (rapid connect/disconnect)
- Backend failure and recovery scenarios
- Resource utilization monitoring

### Reliability Tests
- Network interruption simulation
- Backend service restart scenarios
- Long-running connection stability
- Memory leak detection

---

**Story ID**: S8.5
**Created**: 2025-01-27
**Epic Reference**: [`docs/prd/epic-8-bff-implementation.md`](../prd/epic-8-bff-implementation.md)
**Architecture Reference**: [`docs/architecture/bff-architecture.md`](../architecture/bff-architecture.md)

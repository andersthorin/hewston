# Story 5.1 — Streamer service + frame decimation
Story ID: S5.1
Epic ID: E5



Status: Ready

User Story
- As a backend engineer,
- I want a streamer service that reads run artifacts, produces StreamFrame payloads, and decimates to ≈30 FPS,
- So that playback is smooth, efficient, and ready for transport over WebSocket or SSE.

Context
- Assumes a DONE run with artifacts exists. Focus on producer pipeline and decimation policy; transport added in 5.2/5.3.


Dependencies
- Depends on: S4.2 (artifacts written)
- Blocks: S5.2 (WS transport), S5.3 (SSE fallback)

References
- WS Protocol: docs/api/ws-protocol.md
- Performance Plan: docs/qa/performance-test-plan.md
- Data Models & Artifacts: docs/architecture.md
- Source Tree: docs/architecture/source-tree.md

Definition of Ready
- Context clarified; dependencies and references listed
- ACs measurable and testable; cite canonical docs
- QA mapping present (see docs/qa/story-to-qa-mapping.md)

Acceptance Criteria
1) `services/streamer.py` exposes an async frame producer that yields `{ t:"frame", ts, ohlc, orders, equity, dropped }`
2) Decimation targets ≈30 FPS, independent of original bar cadence; includes dropped counter when client lags
3) Supports control inputs (play, pause, seek, speed) via an in-memory control channel (handled in 5.2, but service API accepts them)
4) Reads artifacts (equity.parquet, orders.parquet, fills.parquet, bars parquet path from dataset) efficiently; no full load when avoidable
5) Non-blocking: uses async iteration and short-lived I/O; no heavy compute on event loop
6) Basic unit tests (optional) validate decimation timing and seek snapping

Dev Notes (sourced from architecture docs)
- StreamFrame schema and WS playback protocol [Source: architecture.md#playback-channel-protocol-websocket]
- Artifacts layout, data sources [Source: architecture.md#data-models]
- NFRs: target ≈30 FPS; drop-oldest policy; no event-loop blocking [Source: architecture.md#non-functional-requirements-and-performance-budgets]

Technical Specifications
- Input: run_id → resolve artifact paths via catalog; dataset_id → bars parquet path
- Producer: async generator that advances a logical clock according to `speed` (time-compression), yielding frames at ≈30 Hz
- Decimation: if source cadence > 30 Hz, select/skips; if < 30 Hz, interpolate time but do not fabricate price data
- dropped: increments when consumer signals lag (wired via 5.2); for now, simulate counter when internal queue overflows
- Seek: snap to nearest bar timestamp; flush pending buffers

Tasks / Subtasks
- Define StreamFrame dataclass/schema and control enums in backend/domain/types.py
- Implement services/streamer.py with async generator API and control hook signatures
- Implement artifact readers (iterators over Parquet) with minimal memory use
- Implement decimator helper that enforces ≈30 FPS target with timing control
- Add light tests for decimation math (optional) and run `make lint`

Testing & Validation
- Use a small sample artifacts set; run producer to collect N frames; verify cadence and fields present
- Simulate seek/play/pause inputs; verify behavior (even if wired via direct calls in test)

Definition of Done
- Streamer service produces decimated StreamFrame payloads with control-aware API; non-blocking; ready for WS/SSE transports.


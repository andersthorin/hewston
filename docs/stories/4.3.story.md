# Story 4.3 — Idempotent POST /backtests (enqueue + status)
Story ID: S4.3
Epic ID: E4



Status: Draft

User Story
- As an API client,
- I want POST /backtests to be idempotent and enqueue work without blocking the request,
- So that I can safely retry and observe run status transitions without duplicating runs.

Context
- Third story of Epic 4. Wires REST create to a background/subprocess job, with idempotency via header and deterministic input hash.

Acceptance Criteria
1) POST /backtests accepts body (dataset_id or symbol/from/to + strategy params) and optional Idempotency-Key header
2) Server computes deterministic input_hash from inputs (order-independent JSON) and checks for existing run
3) First request: respond 202 { run_id, status:"QUEUED" } and launch Typer subprocess for backtest (non-blocking)
4) Repeat with same inputs or same Idempotency-Key: respond 200 { run_id, status:"EXISTS" }
5) Status transitions reflected in catalog: QUEUED→RUNNING→DONE/ERROR; GET endpoints report current status
6) No CPU-bound work in request handler; subprocess launched safely; logs include idempotency_key, input_hash, run_id
7) Lint passes; shapes match OpenAPI

Dev Notes (sourced from architecture docs)
- API Contracts: POST/GET /backtests, idempotency behavior [Source: architecture.md#api-contracts-rest--websocket]
- Determinism & Idempotency: input_hash + Idempotency-Key [Source: architecture.md#determinism--reproducibility-details]
- Catalog schema fields for input_hash and idempotency_key [Source: architecture.md#catalog-schema-sqlite-ddl]
- Non-blocking, subprocess via Typer; security/binding defaults [Source: architecture.md#non-functional-requirements-and-performance-budgets]

Technical Specifications
- Hashing: canonical JSON of relevant inputs (dataset_id or symbol/from/to, strategy_id, params, seed, slippage_fees) → SHA-256 hex string
- Storage: Save input_hash and idempotency_key in runs table (unique); handle UNIQUE violation to find existing run
- Subprocess: launch `uv run -m backend.jobs.cli backtest ...` (or equivalent) with run_id passed; detach/non-blocking
- Response codes: 202 on first create; 200 on repeat; 4xx on validation errors

Tasks / Subtasks
- Implement service method `create_backtest` in services/backtests.py:
  - Validate inputs; compute input_hash; upsert QUEUED run (handle conflict for EXISTING)
  - Launch subprocess for backtest job; return appropriate response
- Update api/routes/backtests.py POST handler to call service; parse Idempotency-Key header
- Ensure GET endpoints read status from catalog
- Add minimal in-memory queue or direct subprocess invocation (no heavy framework)
- `make lint` backend/

Testing & Validation
- Fresh DB: POST new body → 202 QUEUED and run starts; GET shows RUNNING then DONE
- Repeat POST with same Idempotency-Key → 200 EXISTS with same run_id
- Repeat POST with semantically identical inputs (different field ordering) → 200 EXISTS via input_hash

Definition of Done
- POST /backtests is idempotent, enqueues work, and surfaces status transitions via the catalog; conforms to contracts and NFRs.


# Story 5.2 — WebSocket endpoint + control handling
Story ID: S5.2
Epic ID: E5



Status: Ready

User Story
- As a frontend client,
- I want a WebSocket endpoint that streams frames and handles in-band control (play/pause/seek/speed),
- So that I can interactively control time-compressed playback.

Context
- Builds on 5.1 streamer service. Focuses on WS transport, control routing, backpressure handling.


Dependencies
- Depends on: S5.1 (streamer service), S1.2 (WS echo baseline)
- Blocks: S6.2 (Run Detail playback UI)

References
- WS Protocol: docs/api/ws-protocol.md
- Performance Plan: docs/qa/performance-test-plan.md
- Source Tree: docs/architecture/source-tree.md
- Error Codes: docs/api/error-codes.md

Definition of Ready
- Context clarified; dependencies and references listed
- ACs measurable and testable; cite canonical docs
- QA mapping present (see docs/qa/story-to-qa-mapping.md)

Acceptance Criteria
1) WS at `ws://localhost:8000/backtests/{id}/ws` sends `{ "t":"hb" }` heartbeat ~5s and streams `{ "t":"frame", ... }` frames
2) Control messages received from client `{ "t":"ctrl", "cmd":"play|pause|seek|speed", ... }` are routed to streamer; invalid messages return `{ "t":"err", "code":"BAD_CTRL" }`
3) Backpressure: server decimates to ~30 FPS and drops oldest when client cannot keep up; `dropped` counter visible in frames
4) Non-blocking implementation; no CPU-bound work on event loop; safe cleanup on disconnect
5) Logs include run_id and basic counters (frames sent, dropped, ctrl events)

Dev Notes (sourced from architecture docs)
- WS protocol, control schema, heartbeat and errors [Source: architecture.md#playback-channel-protocol-websocket]
- Backpressure & NFRs (≈30 FPS target, jitter budgets) [Source: architecture.md#non-functional-requirements-and-performance-budgets]
- Source Tree boundaries (services/streamer.py, adapters/streams.py) [Source: architecture.md#source-tree-and-module-boundaries]

Technical Specifications
- Implement adapters/streams.py with a WS handler that:
  - Accepts connection; spawns heartbeat task every 5s
  - Subscribes to services/streamer frames async generator for run_id
  - For each client message: validate shape; dispatch ctrl to service; respond with `{ "t":"err" }` on bad input
  - On backpressure (send queue overflow), drop-oldest and increment `dropped`
- Error handling: send `{ "t":"err", code, msg }` and continue where possible; end stream with `{ "t":"end" }`

Tasks / Subtasks
- Implement adapters/streams.py WebSocket route and glue to services/streamer
- Add basic input validation and mapping from ctrl payload to internal control API
- Track counters and include `dropped` in outgoing frame payloads
- Wire route in app/main.py; run `make lint`

Testing & Validation
- Connect with a WS client; verify heartbeat, frame flow, and control effects
- Induce slow consumer (sleep in client); verify dropped counter increments

Definition of Done
- WebSocket endpoint streams frames at ~30 FPS with functional controls and robust backpressure handling; logs are informative; no blocking.

